泛化的转义序列：

形式是，\x后紧跟1个或多个16进制数字或\后紧跟1个、2个或3个八进制数字。

ps：如果 \ 后面跟着的八进制数字超过3个，只有前三个与\构成转义序列；相反，\x要用到后面跟着的所有数字。

![image-20230404211334472](assets/image-20230404211334472.png)

声明使名字被程序所知，而定义负责创建与名字关联的实体。

得到空指针最直接的方法就是用字面值**nullptr**来初始化指针



用常量表达式初始化const对象后，编译器在编译过程中把文件中的每个变量都替换为对应的值。如果一个程序中在多个文件中都含有const对象，每个用了const对象的文件，编译器都必须知道初始值是什么，所以每个文件都必须定义这个const对象。为了避免对同一变量的重复定义，const对象被设定为仅在文件内有效。

如果想在多个文件中共享const变量，必须在变量的定义之前添加extern关键字。



不能给引用赋其他类型的值或者一个表达式，除非前面用const。因为表达式最后的结果是一个临时量，一般来说定义一个引用就是想通过引用改变它的值，但是大家一般不会想改变临时量，也就不会想着把引用绑定到临时量上。所以C++规定这种行为是非法的。赋其他类型的值也是同理。赋其他类型的值的过程中其实是在进行类型强制转化，也可以算作表达式。

对const的引用也称为常量引用，不能通过它改变它所引用的对象。



本身为常量叫顶层const,控制的基本类型部分为常量叫底层const

为了防止不小心改变数据，底层const可以不能赋值给非底层const对象（但是引用好像可以）

顶层const，如指针本身指向的地方不变，它本身的值可以被拷贝给不是顶层const的指针（指针指向的方向改变）

底层const，如指针指向的内容不变，指针本身的值不能被赋值给不是底层const的指针，这有可以有效防止不是底层const的指针随意篡改底层const指针守护的内容。



一些足够简单，支持在编译时就得到计算的类型成为“字面值类型”。字面值类型包括算术类型、引用还有指针等等。不过引用还有指针的初始值受到限制。比如指针只能nullptr或0或某个固定地址的对象。



auto 一般会忽略掉顶层const,同时保留底层const。这意味着把顶层const对象如普通的一个常量，赋值会得到非顶层const的对象，一个变量。如果把控制某一块地方为const的底层const对象赋值，新变量所控制的那块地方仍然不能改变。

设置一个auto的引用时，初始值的顶层常量属性仍然保留。





如果定义变量时没有设置初始值，那么变量将被默认初始化（定义于函数体内的是例外）。类内的成员 默认初始化，但可以凭自己决定不初始化，且按照自己的想法按照给定的类内初始值进行初始化。



![初始化 string 对象的方式](assets/image-20230414193150165.png)

初始化：`=`实行的是拷贝初始化，如果不使用等号，如使用`()`，那么实行的是直接初始化。拷贝初始化就是把等号右边的初始值拷贝赋值给等号左边的对象。



![image-20230414194247425](assets/image-20230414194247425.png)



getline(输入流,string对象) 从给定输入流读取字符串，直到遇到换行符，它读取换行符但是不将其存入string对象。此函数最后返回流参数。

string.empty()返回是否为空。

string.size()返回string对象中字符的个数。返回类型为string::size_type,一个无符号整型数，它保证它能存放无论字符串多长的字符串。

string 有 == >= > < <= 的比较符

string 可以使用加法。可以加字面量或者是字符常量。但 + 两边至少有一个运算对象是string。

注意字符串字面值并非标准库类型string的对象。还有，像下面的语句是对的（每个加法运算符都有一个运算对象是 string)

```c++
string s1 = "hello, ";
string s = s1 + "， " + "world";
```



vector 是模板而非类型，声明的时候尖括号里必须包括数据类型。这个类型不能是引用，因为引用不是一个对象。

![image-20230417153755626](assets/image-20230417153755626.png)

{}花括号内的内容如果与要初始化的变量的数据类型一致，那么就是列表初始化；

```c++
vector<int> v1{1,2,3};  //列表初始化
```

如果不一致，它的用法就像圆括号一样

```c++
vector<string> v2{20};   //v2有20个默认初始化的元素
vector<string> v3{10,"hello"};  //v3有10个值为"hello"的元素
```



vector的empty和size两个成员返回值的类型是由vector定义的size_type类型。



有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置。其他所有情况都属于无效。

如果容器为空，则begin和end返回的都是尾后迭代器。



一般来说，我们并不关心迭代器的精确类型。事实上，那些拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型。

const_iterator像const指针一样，能访问上面的值但是不能改动内容。



begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量，返回 const_iterator ，反之返回 iterator。 有时候我们只想读而不想对数据进行改动，cbegin() 与 cend()只返回 const_iterator 类型。



两个迭代器之间的距离的类型是 difference_type ，因为这个距离可正可负，所以它是带符号类型的。



在函数内部定义的数组的默认初始化跟它的内置类型一样。比如在函数内部，string默认初始化为空字符串，string数组中的每个string都是空字符串；int默认是未定义的，int数组中的每个元素也是未定义的。



大多数表达式中，使用数组类型的变量往往被看作是在使用指向第一个元素的指针。decltype()不会发生这种转化。

```cpp
int a[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia);  //ia2为指针
decltype(ia) ia3;  //ia3为数组
```



数组arr，begin(arr) 返回 arr 首元素的指针；end(arr)返回 arr 尾元素下一位置的指针。



标准库类型（如string、vector）的下标是unsigned类型所以必须是正的。而数组的下标可以是负的，只要指向的元素确实存在或者是数组尾元素的下一位置即可。



string对象转C风格字符串`const char *str = s.c_str();` ，函数的返回结果为`const char*`指针，指向的数组数据恰好与那个string对象的一样。后续对string对象的修改会使其失去效用，所以如果一直想用其返回的数组，最好将其重新拷贝一份。



使用数组初始化vector对象：

```cpp
int arr[]={0,1,2,3,4,5};
vector<int> ivec(begin(arr),end(arr));  //复制全部
vector<int> ivec(arr+1,arr+4);  //复制arr[1],arr[2],arr[3]
```



注意以下的代码第一行&row为引用，为什么将其作为引用呢？

```cpp
for (const auto &row:ia)
    for (auto col:row)
```

因为，如果非引用，第二行的row会被当作一个指针看待，然后出错。要使用范围 for 语句 处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。



除法运算中，如果两个运算对象对象符号相同则为正，反之则为负，商向0取整。



如果 m%n 不等于0，则它的符号和m相同。

m%(-n) 等于 m%n

(-m)%n 等于 -(m%n)

 

递增和递减运算符有前置版本和后置版本。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。 



右移运算符的运算对象如果是无符号类型，在左侧插入 0 的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。



移位运算符的优先级比算术运算符低，但比关系运算符、赋值运算符和条件运算符的优先级高。



sizeof(vec)只取决于vector里面存放的数据类型，与元素个数无关。
